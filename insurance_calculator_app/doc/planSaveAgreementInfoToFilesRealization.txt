Задача:

Необходимо регулярно выгружать данные по полисам в файлы.
Данные по каждому полису должны быть выгружены в отдельные файлы.
Формат файлов: xml.
Данные должны содержать все поля полиса, персон и рисков, а так же
рассчитанные премии.
Данные в файлы необходимо выгружать на регулярной основе,
один раз в сутки.

План реализации:

1. добавляем колонку already_recorded в таблицу agreements с дефолтным значением false

2. предлогается группировать файлы с информацией по каждому полису по папкам,
нужно написать метод saveFolder() для сжатия этих папок, используя java.util.zip.ZipOutputStream,
возможно стоит выбрать облочное хранилище и сохранять файлы туда

3. напишем метод getUuids(), который будет доставать из бд определённое количество
uuid полисов, проверяя остаются ли в таблице agreements незаписанные данные

4. написать метод writeAgreementsToXmlFile(), преобразовывающий объекты класса AgreementDTO в xml используя jaxb:

  для этого добавить @XmlRootElement, @XmlElement(name = "field_name")
  @XmlElementWrapper для объектов и полей AgreementDTO, PersonDTO, RiskDTO

 и записывающий данные в файл с помощью JAXBContext и Marshaller

 5. использовать имеющийся код написанный в предыдущих степах по построению AgreementDTO на основании uuid
  сделать метод getAgreementDTOByUuid()

 6. напишем класс задачи реализующий интерфейс Runnable, принимающий uuid, и путь файла куда надо записать данные;
метод run будет использовать getAgreementDTOByUuid() и writeAgreementsToXmlFile()
и менять метку already_recorded у строки таблицы agreements

7. далее использовать Spring Task Scheduling для выполнения задачи ежедневно:
для этого создадим класс с методом execute() и анотацией  @Scheduled, например
 @Scheduled(cron = "0 0 18 * * *") , что будет означать выполнение метода ежедневно в 18.00

метод execute() будет использовать созданный метод getUuids() и
создадавать объект класса FixedThreadPool в котором нужно определиться с количеством потоков,
возможно протестировав работу приложения с разных их количеством
и туда будем отдавать задачи пока не закончаться
также метод использует saveFolder(), и генерирует названия папок, передаёт пути файлов в runnable объект

8. В классе InsuranceApplication добавляем аннотацию @EnableScheduling,
  чтобы включить поддержку планировщика заданий в наше приложение.

9. написать метод проверки работы метода execute(): в таблице не должно остаться строк с отметкой false столбца already_recorded

10. протестировать написанные методы,
запустить реализованный функционал по отправлению ежесекундных запросов пакета loadtesting
и протестировать работу функционала по записи данных в файлы, поставив в анотации @Scheduled подходящее время


